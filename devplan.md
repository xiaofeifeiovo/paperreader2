# PaperReader2 - AIèåˆè®ºæ–‡è¾…åŠ©é˜…è¯»å™¨å¼€å‘è®¡åˆ’

## ğŸ“‹ é¡¹ç›®èƒŒæ™¯

**é¡¹ç›®åç§°**ï¼šPaperReader2
**é¡¹ç›®ç±»å‹**ï¼šæœ¬åœ°éƒ¨ç½²çš„AIå¢å¼ºå‹è®ºæ–‡é˜…è¯»å™¨
**å¼€å‘ç›®æ ‡**ï¼šå¿«é€Ÿæ„å»ºMVPï¼ˆæœ€å°å¯è¡Œäº§å“ï¼‰ï¼Œåç»­è¿­ä»£ä¼˜åŒ–
**æŠ€æœ¯ç‰¹ç‚¹**ï¼šç®€åŒ–æ¶æ„ã€å¿«é€Ÿå¤„ç†ã€æˆæœ¬å¯æ§

---

## ğŸ¯ æ ¸å¿ƒéœ€æ±‚

### åŠŸèƒ½éœ€æ±‚
1. **æ–‡æ¡£ä¸Šä¼ ä¸è½¬æ¢**
   - æ”¯æŒPDFã€DOCXæ ¼å¼ä¸Šä¼ 
   - è‡ªåŠ¨è½¬æ¢ä¸ºMarkdownæ ¼å¼
   - ä¿ç•™æ–‡æ¡£ä¸­çš„å›¾åƒï¼ˆé«˜åˆ†è¾¨ç‡ï¼‰
   - æ”¯æŒæ•°å­¦å…¬å¼ï¼ˆLaTeXæ ¼å¼ï¼‰

2. **AIé—®ç­”åŠŸèƒ½**
   - åŸºäºä¸Šä¼ çš„è®ºæ–‡å†…å®¹è¿›è¡Œæ™ºèƒ½é—®ç­”
   - ä½¿ç”¨Qwenå¤§æ¨¡å‹
   - æµå¼å“åº”ï¼Œå®æ—¶æ˜¾ç¤ºå›ç­”
   - æ”¯æŒå¯¹è¯å†å²

3. **æ–‡æ¡£æµè§ˆ**
   - Markdownæ¸²æŸ“ï¼ˆæ”¯æŒå…¬å¼ã€å›¾åƒã€è¡¨æ ¼ï¼‰
   - æ–‡æ¡£ç›®å½•å¯¼èˆª
   - æ–‡æ¡£åˆ—è¡¨ç®¡ç†

### éåŠŸèƒ½éœ€æ±‚
- æœ¬åœ°éƒ¨ç½²ï¼Œæ•°æ®éšç§å®‰å…¨
- å¤„ç†é€Ÿåº¦å¿«ï¼ˆä¼˜å…ˆä½¿ç”¨Pix2Textï¼‰
- ç•Œé¢å‹å¥½ï¼Œæ“ä½œç®€å•
- Windows 11å…¼å®¹

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯å±‚ (React + Vite)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  æ–‡ä»¶ä¸Šä¼     â”‚  â”‚  æ–‡æ¡£æŸ¥çœ‹    â”‚  â”‚  AIèŠå¤©      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“ HTTP/SSE
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               APIç½‘å…³å±‚ (FastAPI)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  æ–‡æ¡£API     â”‚  â”‚  èŠå¤©API     â”‚  â”‚  é™æ€èµ„æº    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ä¸šåŠ¡é€»è¾‘å±‚ (Core Services)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  æ–‡æ¡£å¤„ç†    â”‚  â”‚  ä¸Šä¸‹æ–‡ç®¡ç†  â”‚  â”‚  LLMæœåŠ¡     â”‚  â”‚
â”‚  â”‚  Pix2Text    â”‚  â”‚  Tokenè®¡æ•°   â”‚  â”‚  Qwen API    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             æ•°æ®å­˜å‚¨å±‚ (æœ¬åœ°æ–‡ä»¶ç³»ç»Ÿ)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚  uploads/    â”‚  â”‚  processed/  â”‚                    â”‚
â”‚  â”‚  åŸå§‹æ–‡ä»¶    â”‚  â”‚  MD + å›¾åƒ   â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰å‹

#### åç«¯æŠ€æœ¯æ ˆ
| æ¨¡å— | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬è¦æ±‚ | é€‰å‹ç†ç”± |
|------|---------|---------|---------|
| **Webæ¡†æ¶** | FastAPI | >=0.109.0 | é«˜æ€§èƒ½ã€è‡ªåŠ¨æ–‡æ¡£ã€åŸç”Ÿå¼‚æ­¥ |
| **PDFå¤„ç†** | Pix2Text | >=1.1.0 | é€Ÿåº¦å¿«ã€æ”¯æŒOCRå’Œå…¬å¼è¯†åˆ« |
| **PDFè¾…åŠ©** | PyMuPDF | 1.23.8 | é«˜è´¨é‡å›¾åƒæå– |
| **DOCXå¤„ç†** | python-docx | 1.1.0 | å®˜æ–¹æ¨èåº“ |
| **LLMè°ƒç”¨** | dashscope | >=1.14.0 | é˜¿é‡Œäº‘Qwenå®˜æ–¹SDK |
| **Tokenè®¡æ•°** | tiktoken | >=0.5.0 | å‡†ç¡®çš„Tokenç»Ÿè®¡ |
| **æ•°æ®éªŒè¯** | Pydantic | 2.5.3 | FastAPIåŸç”Ÿé›†æˆ |

#### å‰ç«¯æŠ€æœ¯æ ˆ
| æ¨¡å— | æŠ€æœ¯é€‰å‹ | ç‰ˆæœ¬è¦æ±‚ | é€‰å‹ç†ç”± |
|------|---------|---------|---------|
| **æ¡†æ¶** | React | ^18.2.0 | æˆç†Ÿã€ç”Ÿæ€ä¸°å¯Œ |
| **æ„å»ºå·¥å…·** | Vite | ^5.0.12 | å¿«é€Ÿã€ç°ä»£åŒ– |
| **è¯­è¨€** | TypeScript | ^5.3.3 | ç±»å‹å®‰å…¨ |
| **çŠ¶æ€ç®¡ç†** | Zustand | ^4.5.0 | è½»é‡ã€ç®€å• |
| **Markdownæ¸²æŸ“** | react-markdown | ^9.0.1 | åŠŸèƒ½å®Œæ•´ |
| **å…¬å¼æ¸²æŸ“** | KaTeX | ^0.16.9 | å¿«é€Ÿã€è½»é‡ |
| **æ ·å¼** | Tailwind CSS | ^3.4.1 | å¼€å‘æ•ˆç‡é«˜ |
| **HTTPå®¢æˆ·ç«¯** | axios | ^1.6.5 | APIå‹å¥½ |

---

## ğŸ“ é¡¹ç›®ç›®å½•ç»“æ„

```
paperreader2/
â”œâ”€â”€ backend/                          # åç«¯é¡¹ç›®æ ¹ç›®å½•
â”‚   â”œâ”€â”€ app/                          # åº”ç”¨ä»£ç 
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py                   # FastAPIåº”ç”¨å…¥å£
â”‚   â”‚   â”œâ”€â”€ config.py                 # é…ç½®ç®¡ç†ï¼ˆè¯»å–ç¯å¢ƒå˜é‡ï¼‰
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ api/                      # APIè·¯ç”±å±‚
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ v1/
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â”œâ”€â”€ documents.py      # æ–‡æ¡£ç®¡ç†API
â”‚   â”‚   â”‚       â”œâ”€â”€ chat.py           # AIèŠå¤©API
â”‚   â”‚   â”‚       â””â”€â”€ health.py         # å¥åº·æ£€æŸ¥API
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ core/                     # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ document_processor.py # æ–‡æ¡£å¤„ç†åŸºç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ pdf_processor.py      # PDFå¤„ç†å™¨ï¼ˆPix2Textï¼‰
â”‚   â”‚   â”‚   â”œâ”€â”€ docx_processor.py     # DOCXå¤„ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ image_handler.py      # å›¾åƒæå–ä¸ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ context_builder.py    # ä¸Šä¸‹æ–‡æ„å»ºå™¨
â”‚   â”‚   â”‚   â””â”€â”€ llm_service.py        # Qwen LLMè°ƒç”¨æœåŠ¡
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ models/                   # Pydanticæ•°æ®æ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ document.py           # æ–‡æ¡£æ¨¡å‹
â”‚   â”‚   â”‚   â”œâ”€â”€ chat.py               # èŠå¤©æ¨¡å‹
â”‚   â”‚   â”‚   â””â”€â”€ response.py           # APIå“åº”æ¨¡å‹
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ file_utils.py         # æ–‡ä»¶æ“ä½œå·¥å…·
â”‚   â”‚   â”‚   â”œâ”€â”€ markdown_utils.py     # Markdownå¤„ç†å·¥å…·
â”‚   â”‚   â”‚   â””â”€â”€ logger.py             # æ—¥å¿—å·¥å…·
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ storage/                  # å­˜å‚¨ç®¡ç†
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ file_storage.py       # æœ¬åœ°æ–‡ä»¶å­˜å‚¨ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ data/                         # æ•°æ®ç›®å½•ï¼ˆè¿è¡Œæ—¶åˆ›å»ºï¼‰
â”‚   â”‚   â”œâ”€â”€ uploads/                  # åŸå§‹ä¸Šä¼ æ–‡ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ {doc_id}/
â”‚   â”‚   â”‚       â””â”€â”€ original.pdf
â”‚   â”‚   â””â”€â”€ processed/                # å¤„ç†åçš„æ–‡ä»¶
â”‚   â”‚       â”œâ”€â”€ markdown/             # Markdownæ–‡ä»¶
â”‚   â”‚       â”‚   â””â”€â”€ {doc_id}.md
â”‚   â”‚       â””â”€â”€ images/               # æå–çš„å›¾åƒ
â”‚   â”‚           â””â”€â”€ {doc_id}/
â”‚   â”‚               â”œâ”€â”€ img_001.png
â”‚   â”‚               â””â”€â”€ img_002.png
â”‚   â”‚
â”‚   â”œâ”€â”€ tests/                        # æµ‹è¯•ä»£ç 
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ test_pdf_processor.py
â”‚   â”‚   â””â”€â”€ test_llm_service.py
â”‚   â”‚
â”‚   â”œâ”€â”€ requirements.txt              # Pythonä¾èµ–
â”‚   â”œâ”€â”€ .env.example                  # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â”‚   â””â”€â”€ README.md                     # åç«¯è¯´æ˜æ–‡æ¡£
â”‚
â”œâ”€â”€ frontend/                         # å‰ç«¯é¡¹ç›®æ ¹ç›®å½•
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/               # Reactç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ upload/               # ä¸Šä¼ ç›¸å…³ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FileUploader.tsx  # æ–‡ä»¶ä¸Šä¼ å™¨
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UploadProgress.tsx # ä¸Šä¼ è¿›åº¦
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ document/             # æ–‡æ¡£ç›¸å…³ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DocumentViewer.tsx    # æ–‡æ¡£æŸ¥çœ‹å™¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MarkdownRenderer.tsx  # Markdownæ¸²æŸ“å™¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DocumentList.tsx      # æ–‡æ¡£åˆ—è¡¨
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TableOfContents.tsx   # ç›®å½•å¯¼èˆª
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â”œâ”€â”€ chat/                 # èŠå¤©ç›¸å…³ç»„ä»¶
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ChatInterface.tsx     # èŠå¤©ç•Œé¢
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MessageList.tsx       # æ¶ˆæ¯åˆ—è¡¨
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ MessageInput.tsx      # æ¶ˆæ¯è¾“å…¥æ¡†
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ StreamingMessage.tsx  # æµå¼æ¶ˆæ¯æ˜¾ç¤º
â”‚   â”‚   â”‚   â”‚
â”‚   â”‚   â”‚   â””â”€â”€ common/               # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”‚       â”œâ”€â”€ Loading.tsx
â”‚   â”‚   â”‚       â”œâ”€â”€ ErrorBoundary.tsx
â”‚   â”‚   â”‚       â””â”€â”€ Button.tsx
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ hooks/                    # è‡ªå®šä¹‰React Hooks
â”‚   â”‚   â”‚   â”œâ”€â”€ useDocument.ts        # æ–‡æ¡£ç®¡ç†Hook
â”‚   â”‚   â”‚   â”œâ”€â”€ useChat.ts            # èŠå¤©Hook
â”‚   â”‚   â”‚   â””â”€â”€ useStreamingResponse.ts # æµå¼å“åº”Hook
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ services/                 # APIæœåŠ¡å±‚
â”‚   â”‚   â”‚   â”œâ”€â”€ api.ts                # Axiosé…ç½®
â”‚   â”‚   â”‚   â”œâ”€â”€ documentService.ts    # æ–‡æ¡£APIè°ƒç”¨
â”‚   â”‚   â”‚   â””â”€â”€ chatService.ts        # èŠå¤©APIè°ƒç”¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ store/                    # ZustandçŠ¶æ€ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ documentStore.ts      # æ–‡æ¡£çŠ¶æ€
â”‚   â”‚   â”‚   â””â”€â”€ chatStore.ts          # èŠå¤©çŠ¶æ€
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ types/                    # TypeScriptç±»å‹å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ document.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ chat.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ utils/                    # å·¥å…·å‡½æ•°
â”‚   â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â”‚   â””â”€â”€ validators.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ styles/                   # æ ·å¼æ–‡ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”‚   â””â”€â”€ markdown.css
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ App.tsx                   # æ ¹ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ main.tsx                  # å…¥å£æ–‡ä»¶
â”‚   â”‚   â””â”€â”€ vite-env.d.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ public/                       # é™æ€èµ„æº
â”‚   â”‚   â””â”€â”€ favicon.ico
â”‚   â”‚
â”‚   â”œâ”€â”€ index.html
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”œâ”€â”€ tailwind.config.js
â”‚   â””â”€â”€ postcss.config.js
â”‚
â”œâ”€â”€ scripts/                          # å·¥å…·è„šæœ¬
â”‚   â”œâ”€â”€ setup.bat                     # ç¯å¢ƒåˆå§‹åŒ–è„šæœ¬
â”‚   â”œâ”€â”€ start_backend.bat             # å¯åŠ¨åç«¯
â”‚   â”œâ”€â”€ start_frontend.bat            # å¯åŠ¨å‰ç«¯
â”‚   â””â”€â”€ start_all.bat                 # åŒæ—¶å¯åŠ¨å‰åç«¯
â”‚
â”œâ”€â”€ docs/                             # æ–‡æ¡£ç›®å½•
â”‚   â”œâ”€â”€ architecture.md               # æ¶æ„è®¾è®¡æ–‡æ¡£
â”‚   â”œâ”€â”€ api.md                        # APIæ¥å£æ–‡æ¡£
â”‚   â””â”€â”€ deployment.md                 # éƒ¨ç½²æŒ‡å—
â”‚
â”œâ”€â”€ .gitignore
â”œâ”€â”€ README.md                         # é¡¹ç›®è¯´æ˜
â””â”€â”€ devplan.md                        # æœ¬å¼€å‘è®¡åˆ’æ–‡æ¡£
```

---

## ğŸ”„ æ ¸å¿ƒæ•°æ®æµè®¾è®¡

### 1. æ–‡æ¡£ä¸Šä¼ ä¸å¤„ç†æµç¨‹

```
ç”¨æˆ·æ“ä½œï¼šé€‰æ‹©PDF/DOCXæ–‡ä»¶ â†’ ç‚¹å‡»ä¸Šä¼ 
                â†“
å‰ç«¯å¤„ç†ï¼š
    1. æ–‡ä»¶éªŒè¯ï¼ˆæ ¼å¼ã€å¤§å°ï¼‰
    2. åˆ›å»ºä¸Šä¼ è¯·æ±‚
    3. æ˜¾ç¤ºä¸Šä¼ è¿›åº¦æ¡
    4. è°ƒç”¨ POST /api/v1/documents/upload
                â†“
åç«¯æ¥æ”¶ï¼š
    1. æ¥æ”¶æ–‡ä»¶æµ
    2. ç”Ÿæˆå”¯ä¸€æ–‡æ¡£ID (UUID)
    3. ä¿å­˜åŸå§‹æ–‡ä»¶åˆ° data/uploads/{doc_id}/
    4. è¿”å›æ–‡æ¡£IDå’Œå¤„ç†çŠ¶æ€
    5. è§¦å‘åå°å¼‚æ­¥ä»»åŠ¡
                â†“
åå°ä»»åŠ¡ï¼ˆAsyncIOï¼‰ï¼š
    1. æ ¹æ®æ–‡ä»¶æ‰©å±•åé€‰æ‹©å¤„ç†å™¨
       - .pdf â†’ PDFProcessor
       - .docx â†’ DOCXProcessor

    2. PDFå¤„ç†æµç¨‹ï¼ˆPix2Textï¼‰ï¼š
       â”œâ”€ ä½¿ç”¨Pix2Textè¿›è¡ŒOCRè¯†åˆ«
       â”œâ”€ æå–æ–‡æœ¬å†…å®¹ï¼ˆä¿æŒç»“æ„ï¼‰
       â”œâ”€ è¯†åˆ«æ•°å­¦å…¬å¼ï¼ˆè½¬ä¸ºLaTeXï¼‰
       â”œâ”€ ä½¿ç”¨PyMuPDFæå–é«˜è´¨é‡å›¾åƒ
       â”œâ”€ ä¿å­˜å›¾åƒåˆ° data/processed/images/{doc_id}/
       â””â”€ ç”ŸæˆMarkdownæ–‡ä»¶

    3. DOCXå¤„ç†æµç¨‹ï¼ˆpython-docxï¼‰ï¼š
       â”œâ”€ æå–æ®µè½å’Œæ ·å¼
       â”œâ”€ æå–åµŒå…¥å›¾åƒ
       â”œâ”€ è½¬æ¢MathMLå…¬å¼ä¸ºLaTeX
       â””â”€ ç”ŸæˆMarkdownæ–‡ä»¶

    4. ä¿å­˜Markdownåˆ° data/processed/markdown/{doc_id}.md

    5. æ›´æ–°æ–‡æ¡£çŠ¶æ€ä¸º "ready"
                â†“
å‰ç«¯è½®è¯¢/SSEé€šçŸ¥ï¼š
    1. å‰ç«¯å®šæœŸè°ƒç”¨ GET /api/v1/documents/{doc_id}/status
    2. çŠ¶æ€å˜ä¸º "ready" ååœæ­¢è½®è¯¢
    3. è‡ªåŠ¨è·³è½¬åˆ°æ–‡æ¡£æŸ¥çœ‹é¡µé¢
                â†“
æ–‡æ¡£æ¸²æŸ“ï¼š
    1. è°ƒç”¨ GET /api/v1/documents/{doc_id}
    2. è·å–Markdownå†…å®¹
    3. ä½¿ç”¨react-markdownæ¸²æŸ“
    4. KaTeXæ¸²æŸ“æ•°å­¦å…¬å¼
    5. æ‡’åŠ è½½æ˜¾ç¤ºå›¾åƒ
```

### 2. AIé—®ç­”æµç¨‹

```
ç”¨æˆ·æ“ä½œï¼šåœ¨èŠå¤©æ¡†è¾“å…¥é—®é¢˜ â†’ ç‚¹å‡»å‘é€
                â†“
å‰ç«¯å¤„ç†ï¼š
    1. éªŒè¯è¾“å…¥éç©º
    2. æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©å†å²
    3. è°ƒç”¨ POST /api/v1/chat/message
    4. å»ºç«‹SSEè¿æ¥æ¥æ”¶æµå¼å“åº”
                â†“
åç«¯å¤„ç†ï¼ˆchat.pyï¼‰ï¼š
    1. æ¥æ”¶è¯·æ±‚å‚æ•°
       - doc_id: æ–‡æ¡£ID
       - question: ç”¨æˆ·é—®é¢˜
       - history: å¯¹è¯å†å²

    2. è°ƒç”¨ ContextBuilder.build()
       â”œâ”€ è¯»å– data/processed/markdown/{doc_id}.md
       â”œâ”€ ç»Ÿè®¡æ€»Tokenæ•°ï¼ˆä½¿ç”¨tiktokenï¼‰
       â”œâ”€ å¦‚æœè¶…è¿‡é™åˆ¶ï¼ˆå¦‚128kï¼‰ï¼Œæ‰§è¡Œæ™ºèƒ½æˆªæ–­ï¼š
       â”‚  â”œâ”€ ä¼˜å…ˆä¿ç•™ï¼šæ ‡é¢˜ã€æ‘˜è¦ã€å¼•è¨€ã€ç»“è®º
       â”‚  â”œâ”€ å…¶æ¬¡ä¿ç•™ï¼šæ–¹æ³•ã€å®éªŒç»“æœ
       â”‚  â””â”€ æœ€åä¿ç•™ï¼šå‚è€ƒæ–‡çŒ®ç­‰
       â””â”€ æ„å»ºç³»ç»Ÿæç¤ºè¯

    3. è°ƒç”¨ LLMService.stream_chat()
       â”œâ”€ æ„å»ºå®Œæ•´Promptï¼š
       â”‚  ```
       â”‚  System: ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å­¦æœ¯è®ºæ–‡é˜…è¯»åŠ©æ‰‹...
       â”‚
       â”‚  ä»¥ä¸‹æ˜¯è®ºæ–‡å†…å®¹ï¼š
       â”‚  {markdown_content}
       â”‚
       â”‚  å¯¹è¯å†å²ï¼š
       â”‚  {chat_history}
       â”‚
       â”‚  ç”¨æˆ·é—®é¢˜ï¼š{question}
       â”‚  ```
       â”œâ”€ è°ƒç”¨Qwen APIï¼ˆæµå¼æ¨¡å¼ï¼‰
       â”‚  - API: https://dashscope.aliyuncs.com/compatible-mode/v1
       â”‚  - Model: qwen-turbo / qwen-plus
       â”‚  - Stream: true
       â””â”€ é€å—è¿”å›å“åº”
                â†“
æµå¼å“åº”ï¼ˆSSEï¼‰ï¼š
    1. åç«¯ä½¿ç”¨ StreamingResponse
    2. æ¯ä¸ªTokenç”Ÿæˆåç«‹å³å‘é€
    3. æ ¼å¼ï¼šdata: {\"content\": \"token\", \"done\": false}
    4. ç»“æŸæ ‡è®°ï¼šdata: {\"done\": true}
                â†“
å‰ç«¯æ˜¾ç¤ºï¼š
    1. ç›‘å¬SSEäº‹ä»¶
    2. é€å­—æ˜¾ç¤ºå›ç­”ï¼ˆæ‰“å­—æœºæ•ˆæœï¼‰
    3. å®Œæˆåä¿å­˜åˆ°å¯¹è¯å†å²
    4. å…è®¸ç»§ç»­æé—®
```

### 3. æ–‡æ¡£åˆ—è¡¨ç®¡ç†æµç¨‹

```
ç”¨æˆ·æ“ä½œï¼šæ‰“å¼€åº”ç”¨é¦–é¡µ
                â†“
å‰ç«¯è°ƒç”¨ï¼šGET /api/v1/documents/list
                â†“
åç«¯å¤„ç†ï¼š
    1. æ‰«æ data/uploads/ ç›®å½•
    2. è¯»å–æ¯ä¸ªæ–‡æ¡£çš„å…ƒæ•°æ®
    3. è¿”å›æ–‡æ¡£åˆ—è¡¨ï¼š
       - doc_id
       - filename
       - upload_time
       - status (processing/ready/error)
       - file_size
                â†“
å‰ç«¯æ˜¾ç¤ºï¼š
    1. æ¸²æŸ“æ–‡æ¡£åˆ—è¡¨å¡ç‰‡
    2. æ˜¾ç¤ºå¤„ç†çŠ¶æ€
    3. æä¾›æ“ä½œæŒ‰é’®ï¼š
       - æŸ¥çœ‹æ–‡æ¡£
       - å¼€å§‹èŠå¤©
       - åˆ é™¤æ–‡æ¡£
```

---

## ğŸ”§ å…³é”®æ¨¡å—è¯¦ç»†è®¾è®¡

### 1. PDFå¤„ç†æ¨¡å—ï¼ˆbackend/app/core/pdf_processor.pyï¼‰

#### æ ¸å¿ƒèŒè´£
- ä½¿ç”¨Pix2Textè¿›è¡ŒOCRè¯†åˆ«å’Œå…¬å¼æå–
- ä½¿ç”¨PyMuPDFæå–é«˜è´¨é‡å›¾åƒ
- ç”Ÿæˆç»“æ„åŒ–çš„Markdownæ–‡æ¡£

#### å®ç°æ–¹æ¡ˆ

```python
from pix2text import Pix2Text
import fitz  # PyMuPDF
from pathlib import Path
from typing import Tuple, List

class PDFProcessor:
    """PDFæ–‡æ¡£å¤„ç†å™¨ï¼Œä½¿ç”¨Pix2Textå’ŒPyMuPDF"""

    def __init__(self):
        # åˆå§‹åŒ–Pix2Textï¼ˆæ”¯æŒå…¬å¼è¯†åˆ«ï¼‰
        self.p2t = Pix2Text.from_config()

    def process(self, pdf_path: str, doc_id: str, output_dir: str) -> Tuple[str, List[str]]:
        """
        å¤„ç†PDFæ–‡ä»¶ï¼Œè¿”å›Markdownå†…å®¹å’Œå›¾åƒè·¯å¾„åˆ—è¡¨

        Args:
            pdf_path: PDFæ–‡ä»¶è·¯å¾„
            doc_id: æ–‡æ¡£ID
            output_dir: è¾“å‡ºç›®å½•

        Returns:
            (markdown_content, image_paths)
        """
        # 1. ä½¿ç”¨Pix2Textè¿›è¡Œå…¨æ–‡è¯†åˆ«
        markdown_content = self._ocr_with_pix2text(pdf_path)

        # 2. ä½¿ç”¨PyMuPDFæå–é«˜è´¨é‡å›¾åƒ
        image_paths = self._extract_images_with_pymupdf(
            pdf_path, doc_id, output_dir
        )

        # 3. åœ¨Markdownä¸­æ’å…¥å›¾åƒå¼•ç”¨
        final_markdown = self._insert_image_references(
            markdown_content, image_paths
        )

        return final_markdown, image_paths

    def _ocr_with_pix2text(self, pdf_path: str) -> str:
        """ä½¿ç”¨Pix2Textè¿›è¡ŒOCRè¯†åˆ«"""
        # Pix2Textæ”¯æŒç›´æ¥å¤„ç†PDF
        result = self.p2t.recognize_pdf(
            pdf_path,
            return_text=True,
            rec_config={'formula_ocr': True}  # å¯ç”¨å…¬å¼è¯†åˆ«
        )

        # ç»“æœå·²ç»æ˜¯Markdownæ ¼å¼ï¼ˆåŒ…å«LaTeXå…¬å¼ï¼‰
        return result['text']

    def _extract_images_with_pymupdf(
        self, pdf_path: str, doc_id: str, output_dir: str
    ) -> List[str]:
        """ä½¿ç”¨PyMuPDFæå–é«˜è´¨é‡å›¾åƒ"""
        doc = fitz.open(pdf_path)
        image_dir = Path(output_dir) / "images" / doc_id
        image_dir.mkdir(parents=True, exist_ok=True)

        image_paths = []
        img_index = 1

        for page_num in range(len(doc)):
            page = doc[page_num]
            image_list = page.get_images()

            for img in image_list:
                xref = img[0]
                base_image = doc.extract_image(xref)
                image_bytes = base_image["image"]

                # ä¿å­˜å›¾åƒ
                img_filename = f"img_{img_index:03d}.png"
                img_path = image_dir / img_filename

                with open(img_path, "wb") as f:
                    f.write(image_bytes)

                image_paths.append(str(img_path))
                img_index += 1

        doc.close()
        return image_paths

    def _insert_image_references(
        self, markdown: str, image_paths: List[str]
    ) -> str:
        """åœ¨Markdownä¸­æ’å…¥å›¾åƒå¼•ç”¨"""
        # ç®€åŒ–ç‰ˆï¼šåœ¨æ–‡æ¡£æœ«å°¾æ·»åŠ æ‰€æœ‰å›¾åƒ
        # å®é™…å®ç°å¯ä»¥æ›´æ™ºèƒ½åœ°æ’å…¥å›¾åƒä½ç½®

        if not image_paths:
            return markdown

        images_section = "\n\n## æ–‡æ¡£å›¾åƒ\n\n"
        for i, img_path in enumerate(image_paths, 1):
            # è½¬æ¢ä¸ºç›¸å¯¹APIè·¯å¾„
            img_id = Path(img_path).stem
            doc_id = Path(img_path).parent.name
            api_path = f"/api/v1/documents/{doc_id}/images/{img_id}"
            images_section += f"![å›¾{i}]({api_path})\n\n"

        return markdown + images_section

# é…ç½®é€‰é¡¹ï¼šæ”¯æŒå‡çº§åˆ°marker-pdf
USE_MARKER = False  # ä»ç¯å¢ƒå˜é‡è¯»å–

if USE_MARKER:
    # æœªæ¥å‡çº§é€‰é¡¹
    # from marker.convert import convert_single_pdf
    pass
```

#### å…³é”®æŠ€æœ¯ç‚¹

1. **Pix2Textä¼˜åŠ¿**
   - å¼€ç®±å³ç”¨çš„å…¬å¼è¯†åˆ«èƒ½åŠ›
   - æ”¯æŒä¸­è‹±æ–‡æ··æ’
   - ç›´æ¥è¾“å‡ºMarkdownæ ¼å¼
   - å¤„ç†é€Ÿåº¦å¿«

2. **PyMuPDFä¼˜åŠ¿**
   - æå–åŸå§‹é«˜è´¨é‡å›¾åƒï¼ˆéæˆªå›¾ï¼‰
   - é€Ÿåº¦å¿«ã€å†…å­˜å ç”¨å°
   - æ”¯æŒå„ç§PDFæ ¼å¼

3. **å‡çº§è·¯å¾„**
   - é€šè¿‡ç¯å¢ƒå˜é‡ `USE_MARKER=true` å¯åˆ‡æ¢åˆ°marker-pdf
   - marker-pdfæä¾›æ›´é«˜è´¨é‡çš„å¸ƒå±€è¯†åˆ«
   - é€‚åˆå¯¹è´¨é‡è¦æ±‚æé«˜çš„åœºæ™¯

---

### 2. ä¸Šä¸‹æ–‡æ„å»ºæ¨¡å—ï¼ˆbackend/app/core/context_builder.pyï¼‰

#### æ ¸å¿ƒèŒè´£
- è¯»å–Markdownæ–‡æ¡£å†…å®¹
- ç»Ÿè®¡Tokenæ•°é‡
- æ™ºèƒ½æˆªæ–­é•¿æ–‡æ¡£
- ç®¡ç†å¯¹è¯å†å²

#### å®ç°æ–¹æ¡ˆ

```python
import tiktoken
from typing import List, Dict
from pathlib import Path

class ContextBuilder:
    """ä¸Šä¸‹æ–‡æ„å»ºå™¨ï¼Œç®¡ç†æ–‡æ¡£å†…å®¹å’Œå¯¹è¯å†å²"""

    def __init__(self, max_tokens: int = 120000):
        """
        åˆå§‹åŒ–ä¸Šä¸‹æ–‡æ„å»ºå™¨

        Args:
            max_tokens: æœ€å¤§Tokenæ•°ï¼ˆç•™å‡ºä½™é‡ç»™å›å¤ï¼‰
        """
        self.max_tokens = max_tokens
        # ä½¿ç”¨tiktokenç»Ÿè®¡Tokenï¼ˆå…¼å®¹å¤šç§æ¨¡å‹ï¼‰
        self.encoder = tiktoken.get_encoding("cl100k_base")

    def build_context(
        self,
        doc_id: str,
        question: str,
        chat_history: List[Dict[str, str]],
        markdown_dir: str
    ) -> str:
        """
        æ„å»ºå®Œæ•´çš„ä¸Šä¸‹æ–‡Prompt

        Args:
            doc_id: æ–‡æ¡£ID
            question: ç”¨æˆ·é—®é¢˜
            chat_history: å¯¹è¯å†å² [{"role": "user", "content": "..."}, ...]
            markdown_dir: Markdownæ–‡ä»¶ç›®å½•

        Returns:
            å®Œæ•´çš„Promptå­—ç¬¦ä¸²
        """
        # 1. è¯»å–æ–‡æ¡£å†…å®¹
        md_path = Path(markdown_dir) / f"{doc_id}.md"
        with open(md_path, "r", encoding="utf-8") as f:
            document_content = f.read()

        # 2. ç»Ÿè®¡å„éƒ¨åˆ†Token
        doc_tokens = self._count_tokens(document_content)
        history_tokens = self._count_tokens(
            self._format_history(chat_history)
        )
        question_tokens = self._count_tokens(question)
        system_tokens = 500  # ç³»ç»Ÿæç¤ºè¯é¢„ä¼°

        total_tokens = (
            doc_tokens + history_tokens +
            question_tokens + system_tokens
        )

        # 3. å¦‚æœè¶…è¿‡é™åˆ¶ï¼Œæ™ºèƒ½æˆªæ–­æ–‡æ¡£
        if total_tokens > self.max_tokens:
            target_doc_tokens = (
                self.max_tokens - history_tokens -
                question_tokens - system_tokens
            )
            document_content = self._truncate_document(
                document_content, target_doc_tokens
            )

        # 4. æ„å»ºå®Œæ•´Prompt
        prompt = self._build_prompt(
            document_content, chat_history, question
        )

        return prompt

    def _count_tokens(self, text: str) -> int:
        """ç»Ÿè®¡æ–‡æœ¬çš„Tokenæ•°é‡"""
        return len(self.encoder.encode(text))

    def _truncate_document(
        self, content: str, target_tokens: int
    ) -> str:
        """
        æ™ºèƒ½æˆªæ–­æ–‡æ¡£å†…å®¹

        ç­–ç•¥ï¼š
        1. ä¼˜å…ˆä¿ç•™ï¼šæ ‡é¢˜ã€æ‘˜è¦ã€å¼•è¨€ã€ç»“è®º
        2. å…¶æ¬¡ä¿ç•™ï¼šæ–¹æ³•ã€å®éªŒç»“æœ
        3. æœ€åä¿ç•™ï¼šè¯¦ç»†æè¿°ã€å‚è€ƒæ–‡çŒ®
        """
        sections = self._parse_sections(content)

        # å®šä¹‰ä¼˜å…ˆçº§
        priority_keywords = {
            'high': ['abstract', 'introduction', 'conclusion',
                     'æ‘˜è¦', 'å¼•è¨€', 'ç»“è®º'],
            'medium': ['method', 'experiment', 'result',
                       'æ–¹æ³•', 'å®éªŒ', 'ç»“æœ'],
            'low': ['reference', 'appendix', 'å‚è€ƒæ–‡çŒ®', 'é™„å½•']
        }

        # æŒ‰ä¼˜å…ˆçº§é€‰æ‹©ç« èŠ‚
        selected_content = []
        current_tokens = 0

        # å…ˆæ·»åŠ é«˜ä¼˜å…ˆçº§ç« èŠ‚
        for section in sections:
            if any(kw in section['title'].lower()
                   for kw in priority_keywords['high']):
                section_tokens = self._count_tokens(section['content'])
                if current_tokens + section_tokens <= target_tokens:
                    selected_content.append(section['content'])
                    current_tokens += section_tokens

        # å¦‚æœè¿˜æœ‰ç©ºé—´ï¼Œæ·»åŠ ä¸­ä¼˜å…ˆçº§ç« èŠ‚
        if current_tokens < target_tokens:
            for section in sections:
                if any(kw in section['title'].lower()
                       for kw in priority_keywords['medium']):
                    section_tokens = self._count_tokens(
                        section['content']
                    )
                    if current_tokens + section_tokens <= target_tokens:
                        selected_content.append(section['content'])
                        current_tokens += section_tokens

        return "\n\n".join(selected_content)

    def _parse_sections(self, content: str) -> List[Dict[str, str]]:
        """è§£æMarkdownç« èŠ‚"""
        sections = []
        current_section = None

        for line in content.split('\n'):
            if line.startswith('# ') or line.startswith('## '):
                if current_section:
                    sections.append(current_section)
                current_section = {
                    'title': line.strip('# '),
                    'content': line + '\n'
                }
            elif current_section:
                current_section['content'] += line + '\n'

        if current_section:
            sections.append(current_section)

        return sections

    def _format_history(self, chat_history: List[Dict]) -> str:
        """æ ¼å¼åŒ–å¯¹è¯å†å²"""
        formatted = []
        for msg in chat_history[-10:]:  # åªä¿ç•™æœ€è¿‘10è½®å¯¹è¯
            role = "ç”¨æˆ·" if msg["role"] == "user" else "åŠ©æ‰‹"
            formatted.append(f"{role}: {msg['content']}")
        return "\n".join(formatted)

    def _build_prompt(
        self, document: str, history: List[Dict], question: str
    ) -> str:
        """æ„å»ºæœ€ç»ˆPrompt"""
        system_prompt = """ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å­¦æœ¯è®ºæ–‡é˜…è¯»åŠ©æ‰‹ã€‚ä½ çš„ä»»åŠ¡æ˜¯å¸®åŠ©ç”¨æˆ·ç†è§£å’Œåˆ†æè®ºæ–‡å†…å®¹ã€‚

è¯·éµå¾ªä»¥ä¸‹åŸåˆ™ï¼š
1. ä»…åŸºäºæä¾›çš„è®ºæ–‡å†…å®¹å›ç­”é—®é¢˜
2. å¦‚æœè®ºæ–‡ä¸­æ²¡æœ‰ç›¸å…³ä¿¡æ¯ï¼Œè¯·æ˜ç¡®å‘ŠçŸ¥ç”¨æˆ·
3. å›ç­”è¦å‡†ç¡®ã€ç®€æ´ã€æœ‰æ¡ç†
4. å¯ä»¥å¼•ç”¨è®ºæ–‡ä¸­çš„å…·ä½“å†…å®¹
5. å¯¹äºå¤æ‚æ¦‚å¿µï¼Œæä¾›æ¸…æ™°çš„è§£é‡Š"""

        prompt = f"""{system_prompt}

## è®ºæ–‡å†…å®¹

{document}

## å¯¹è¯å†å²

{self._format_history(history)}

## ç”¨æˆ·é—®é¢˜

{question}

è¯·æ ¹æ®ä»¥ä¸Šè®ºæ–‡å†…å®¹å›ç­”ç”¨æˆ·é—®é¢˜ï¼š"""

        return prompt
```

#### å…³é”®æŠ€æœ¯ç‚¹

1. **Tokenè®¡æ•°**
   - ä½¿ç”¨tiktokenåº“ç²¾ç¡®è®¡æ•°
   - å…¼å®¹å¤šç§æ¨¡å‹çš„Tokenè®¡ç®—æ–¹å¼

2. **æ™ºèƒ½æˆªæ–­**
   - åŸºäºç« èŠ‚è¯­ä¹‰çš„æˆªæ–­
   - ä¼˜å…ˆä¿ç•™å…³é”®ä¿¡æ¯
   - é¿å…ç ´åä¸Šä¸‹æ–‡è¿è´¯æ€§

3. **å¯¹è¯å†å²ç®¡ç†**
   - åªä¿ç•™æœ€è¿‘Nè½®å¯¹è¯
   - é¿å…å†å²è¿‡é•¿å ç”¨ä¸Šä¸‹æ–‡

---

### 3. LLMæœåŠ¡æ¨¡å—ï¼ˆbackend/app/core/llm_service.pyï¼‰

#### æ ¸å¿ƒèŒè´£
- è°ƒç”¨Qwen API
- æ”¯æŒæµå¼å“åº”
- é”™è¯¯å¤„ç†å’Œé‡è¯•

#### å®ç°æ–¹æ¡ˆ

```python
import os
from typing import AsyncGenerator, Optional
from dashscope import Generation
import dashscope

class LLMService:
    """Qwenå¤§æ¨¡å‹è°ƒç”¨æœåŠ¡"""

    def __init__(self):
        # ä»ç¯å¢ƒå˜é‡è¯»å–APIå¯†é’¥
        self.api_key = os.getenv("DASHSCOPE_API_KEY")
        if not self.api_key:
            raise ValueError("DASHSCOPE_API_KEY environment variable not set")

        dashscope.api_key = self.api_key

        # æ¨¡å‹é…ç½®
        self.model = "qwen-plus"  # å¯é€‰: qwen-turbo, qwen-max
        self.temperature = 0.3    # ä½æ¸©åº¦ç¡®ä¿å‡†ç¡®æ€§

    async def stream_chat(
        self,
        prompt: str,
        max_tokens: int = 4096
    ) -> AsyncGenerator[str, None]:
        """
        æµå¼è°ƒç”¨Qwen API

        Args:
            prompt: å®Œæ•´çš„Prompt
            max_tokens: æœ€å¤§ç”ŸæˆTokenæ•°

        Yields:
            ç”Ÿæˆçš„æ–‡æœ¬ç‰‡æ®µ
        """
        try:
            responses = Generation.call(
                model=self.model,
                prompt=prompt,
                max_tokens=max_tokens,
                temperature=self.temperature,
                result_format='message',  # ä½¿ç”¨messageæ ¼å¼
                stream=True,              # å¯ç”¨æµå¼è¾“å‡º
                incremental_output=True   # å¢é‡è¾“å‡º
            )

            for response in responses:
                if response.status_code == 200:
                    # æå–ç”Ÿæˆçš„æ–‡æœ¬
                    chunk = response.output.choices[0].message.content
                    yield chunk
                else:
                    # é”™è¯¯å¤„ç†
                    error_msg = (
                        f"APIè°ƒç”¨å¤±è´¥: {response.code} - "
                        f"{response.message}"
                    )
                    yield f"\n\n[é”™è¯¯: {error_msg}]"
                    break

        except Exception as e:
            error_msg = f"LLMæœåŠ¡å¼‚å¸¸: {str(e)}"
            yield f"\n\n[é”™è¯¯: {error_msg}]"

    async def chat(
        self,
        prompt: str,
        max_tokens: int = 4096
    ) -> str:
        """
        éæµå¼è°ƒç”¨ï¼ˆç”¨äºæµ‹è¯•ï¼‰

        Args:
            prompt: å®Œæ•´çš„Prompt
            max_tokens: æœ€å¤§ç”ŸæˆTokenæ•°

        Returns:
            å®Œæ•´çš„å›ç­”æ–‡æœ¬
        """
        try:
            response = Generation.call(
                model=self.model,
                prompt=prompt,
                max_tokens=max_tokens,
                temperature=self.temperature,
                result_format='message'
            )

            if response.status_code == 200:
                return response.output.choices[0].message.content
            else:
                return f"APIè°ƒç”¨å¤±è´¥: {response.code} - {response.message}"

        except Exception as e:
            return f"LLMæœåŠ¡å¼‚å¸¸: {str(e)}"
```

#### APIé…ç½®

æ ¹æ®ç¯å¢ƒå˜é‡é…ç½®ï¼š
- `DASHSCOPE_API_KEY`: sk-82d82b70e6dc42829b9d5c843e0ebab8
- `QWEN_API_BASE`: https://dashscope.aliyuncs.com/compatible-mode/v1

#### æ¨¡å‹é€‰æ‹©

| æ¨¡å‹ | ä¸Šä¸‹æ–‡é•¿åº¦ | é€Ÿåº¦ | æˆæœ¬ | æ¨èåœºæ™¯ |
|------|-----------|------|------|---------|
| qwen-turbo | 8k | å¿« | ä½ | ç®€å•é—®ç­”ã€å¿«é€Ÿå“åº” |
| qwen-plus | 128k | ä¸­ | ä¸­ | **æ¨èï¼šè®ºæ–‡é˜…è¯»** |
| qwen-max | 8k | æ…¢ | é«˜ | å¤æ‚æ¨ç†ã€é«˜è´¨é‡å›ç­” |

**MVPé˜¶æ®µæ¨è**ï¼šqwen-plusï¼ˆä¸Šä¸‹æ–‡é•¿åº¦è¶³å¤Ÿï¼Œæ€§ä»·æ¯”é«˜ï¼‰

---

### 4. FastAPIè·¯ç”±è®¾è®¡

#### æ–‡æ¡£APIï¼ˆbackend/app/api/v1/documents.pyï¼‰

```python
from fastapi import APIRouter, UploadFile, File, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse, StreamingResponse
from pathlib import Path
import uuid
from typing import List

router = APIRouter(prefix="/documents", tags=["documents"])

@router.post("/upload")
async def upload_document(
    file: UploadFile = File(...),
    background_tasks: BackgroundTasks = None
):
    """
    ä¸Šä¼ æ–‡æ¡£å¹¶å¯åŠ¨å¼‚æ­¥å¤„ç†

    æ”¯æŒæ ¼å¼: PDF, DOCX
    """
    # 1. éªŒè¯æ–‡ä»¶æ ¼å¼
    allowed_extensions = ['.pdf', '.docx']
    file_ext = Path(file.filename).suffix.lower()

    if file_ext not in allowed_extensions:
        raise HTTPException(
            status_code=400,
            detail=f"ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ã€‚å…è®¸çš„æ ¼å¼: {allowed_extensions}"
        )

    # 2. ç”Ÿæˆå”¯ä¸€æ–‡æ¡£ID
    doc_id = str(uuid.uuid4())

    # 3. ä¿å­˜åŸå§‹æ–‡ä»¶
    upload_dir = Path("data/uploads") / doc_id
    upload_dir.mkdir(parents=True, exist_ok=True)

    file_path = upload_dir / f"original{file_ext}"
    with open(file_path, "wb") as f:
        content = await file.read()
        f.write(content)

    # 4. æ·»åŠ åå°å¤„ç†ä»»åŠ¡
    background_tasks.add_task(
        process_document,
        doc_id=doc_id,
        file_path=str(file_path),
        file_type=file_ext[1:]  # å»æ‰ç‚¹å·
    )

    return {
        "doc_id": doc_id,
        "filename": file.filename,
        "status": "processing",
        "message": "æ–‡æ¡£æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™..."
    }

@router.get("/{doc_id}")
async def get_document(doc_id: str):
    """è·å–å¤„ç†åçš„æ–‡æ¡£å†…å®¹"""
    md_path = Path("data/processed/markdown") / f"{doc_id}.md"

    if not md_path.exists():
        raise HTTPException(
            status_code=404,
            detail="æ–‡æ¡£ä¸å­˜åœ¨æˆ–æ­£åœ¨å¤„ç†ä¸­"
        )

    with open(md_path, "r", encoding="utf-8") as f:
        content = f.read()

    return {
        "doc_id": doc_id,
        "content": content,
        "status": "ready"
    }

@router.get("/{doc_id}/images/{image_name}")
async def get_image(doc_id: str, image_name: str):
    """è·å–æ–‡æ¡£ä¸­çš„å›¾åƒ"""
    img_path = Path("data/processed/images") / doc_id / f"{image_name}.png"

    if not img_path.exists():
        raise HTTPException(status_code=404, detail="å›¾åƒä¸å­˜åœ¨")

    return FileResponse(img_path, media_type="image/png")

@router.get("/list")
async def list_documents():
    """è·å–æ‰€æœ‰æ–‡æ¡£åˆ—è¡¨"""
    uploads_dir = Path("data/uploads")

    if not uploads_dir.exists():
        return {"documents": []}

    documents = []
    for doc_dir in uploads_dir.iterdir():
        if doc_dir.is_dir():
            doc_id = doc_dir.name

            # æ£€æŸ¥å¤„ç†çŠ¶æ€
            md_path = Path("data/processed/markdown") / f"{doc_id}.md"
            status = "ready" if md_path.exists() else "processing"

            # è·å–åŸå§‹æ–‡ä»¶ä¿¡æ¯
            original_files = list(doc_dir.glob("original.*"))
            if original_files:
                original_file = original_files[0]
                documents.append({
                    "doc_id": doc_id,
                    "filename": original_file.name,
                    "status": status,
                    "upload_time": original_file.stat().st_ctime
                })

    # æŒ‰ä¸Šä¼ æ—¶é—´å€’åºæ’åº
    documents.sort(key=lambda x: x["upload_time"], reverse=True)

    return {"documents": documents}

@router.delete("/{doc_id}")
async def delete_document(doc_id: str):
    """åˆ é™¤æ–‡æ¡£åŠå…¶æ‰€æœ‰ç›¸å…³æ–‡ä»¶"""
    import shutil

    # åˆ é™¤ä¸Šä¼ æ–‡ä»¶
    upload_dir = Path("data/uploads") / doc_id
    if upload_dir.exists():
        shutil.rmtree(upload_dir)

    # åˆ é™¤Markdownæ–‡ä»¶
    md_path = Path("data/processed/markdown") / f"{doc_id}.md"
    if md_path.exists():
        md_path.unlink()

    # åˆ é™¤å›¾åƒç›®å½•
    image_dir = Path("data/processed/images") / doc_id
    if image_dir.exists():
        shutil.rmtree(image_dir)

    return {"message": "æ–‡æ¡£å·²åˆ é™¤", "doc_id": doc_id}


# åå°å¤„ç†å‡½æ•°
async def process_document(doc_id: str, file_path: str, file_type: str):
    """åå°å¼‚æ­¥å¤„ç†æ–‡æ¡£"""
    try:
        if file_type == "pdf":
            from app.core.pdf_processor import PDFProcessor
            processor = PDFProcessor()
        elif file_type == "docx":
            from app.core.docx_processor import DOCXProcessor
            processor = DOCXProcessor()
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: {file_type}")

        # å¤„ç†æ–‡æ¡£
        markdown_content, image_paths = processor.process(
            file_path, doc_id, "data/processed"
        )

        # ä¿å­˜Markdown
        md_dir = Path("data/processed/markdown")
        md_dir.mkdir(parents=True, exist_ok=True)

        md_path = md_dir / f"{doc_id}.md"
        with open(md_path, "w", encoding="utf-8") as f:
            f.write(markdown_content)

    except Exception as e:
        # è®°å½•é”™è¯¯æ—¥å¿—
        print(f"æ–‡æ¡£å¤„ç†å¤±è´¥: {doc_id}, é”™è¯¯: {str(e)}")
        # TODO: æ›´æ–°æ–‡æ¡£çŠ¶æ€ä¸ºerror
```

#### èŠå¤©APIï¼ˆbackend/app/api/v1/chat.pyï¼‰

```python
from fastapi import APIRouter, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from typing import List, Dict
import json

router = APIRouter(prefix="/chat", tags=["chat"])

class ChatRequest(BaseModel):
    doc_id: str
    question: str
    history: List[Dict[str, str]] = []

@router.post("/message")
async def chat_message(request: ChatRequest):
    """
    å‘é€èŠå¤©æ¶ˆæ¯ï¼Œè¿”å›æµå¼å“åº”

    è¯·æ±‚ä½“:
    {
        "doc_id": "æ–‡æ¡£ID",
        "question": "ç”¨æˆ·é—®é¢˜",
        "history": [
            {"role": "user", "content": "ä¹‹å‰çš„é—®é¢˜"},
            {"role": "assistant", "content": "ä¹‹å‰çš„å›ç­”"}
        ]
    }
    """
    from app.core.context_builder import ContextBuilder
    from app.core.llm_service import LLMService

    # 1. æ„å»ºä¸Šä¸‹æ–‡
    context_builder = ContextBuilder()
    try:
        prompt = context_builder.build_context(
            doc_id=request.doc_id,
            question=request.question,
            chat_history=request.history,
            markdown_dir="data/processed/markdown"
        )
    except FileNotFoundError:
        raise HTTPException(
            status_code=404,
            detail="æ–‡æ¡£ä¸å­˜åœ¨ï¼Œè¯·å…ˆä¸Šä¼ å¹¶å¤„ç†æ–‡æ¡£"
        )

    # 2. è°ƒç”¨LLMæœåŠ¡ï¼ˆæµå¼ï¼‰
    llm_service = LLMService()

    async def generate():
        """ç”Ÿæˆå™¨å‡½æ•°ï¼Œç”¨äºSSEæµå¼ä¼ è¾“"""
        try:
            async for chunk in llm_service.stream_chat(prompt):
                # SSEæ ¼å¼ï¼šdata: {json}\n\n
                data = {
                    "content": chunk,
                    "done": False
                }
                yield f"data: {json.dumps(data, ensure_ascii=False)}\n\n"

            # å‘é€ç»“æŸæ ‡è®°
            yield f"data: {json.dumps({'done': True})}\n\n"

        except Exception as e:
            error_data = {
                "error": str(e),
                "done": True
            }
            yield f"data: {json.dumps(error_data, ensure_ascii=False)}\n\n"

    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
        }
    )

@router.get("/history/{doc_id}")
async def get_chat_history(doc_id: str):
    """
    è·å–æ–‡æ¡£çš„èŠå¤©å†å²

    æ³¨æ„ï¼šMVPé˜¶æ®µæš‚ä¸æŒä¹…åŒ–å†å²ï¼Œç”±å‰ç«¯ç®¡ç†
    """
    # TODO: å®ç°å†å²è®°å½•æŒä¹…åŒ–
    return {"history": []}
```

---

## ğŸ“¦ ä¾èµ–é…ç½®

### backend/requirements.txt

```txt
# Webæ¡†æ¶
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-multipart==0.0.6

# PDFå¤„ç†
pix2text>=1.1.0           # ä¸»è¦æ–¹æ¡ˆï¼šOCR + å…¬å¼è¯†åˆ«
pymupdf==1.23.8           # å›¾åƒæå–
# marker-pdf>=0.2.6       # å‡çº§é€‰é¡¹ï¼ˆæ³¨é‡Šï¼ŒæŒ‰éœ€å¯ç”¨ï¼‰

# DOCXå¤„ç†
python-docx==1.1.0

# LLM
dashscope>=1.14.0         # é˜¿é‡Œäº‘Qwen SDK

# Tokenè®¡æ•°
tiktoken>=0.5.0

# æ•°æ®å¤„ç†
pydantic==2.5.3
pydantic-settings==2.1.0

# å·¥å…·
aiofiles==23.2.1
python-dotenv==1.0.0

# å¼€å‘å·¥å…·
pytest>=7.4.0
pytest-asyncio>=0.21.0
```

### frontend/package.json

```json
{
  "name": "paperreader2-frontend",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-markdown": "^9.0.1",
    "remark-gfm": "^4.0.0",
    "remark-math": "^6.0.0",
    "rehype-katex": "^7.0.0",
    "katex": "^0.16.9",
    "axios": "^1.6.5",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@vitejs/plugin-react": "^4.2.1",
    "typescript": "^5.3.3",
    "vite": "^5.0.12",
    "tailwindcss": "^3.4.1",
    "postcss": "^8.4.33",
    "autoprefixer": "^10.4.17"
  }
}
```

---

## ğŸš€ å¼€å‘è®¡åˆ’ä¸é‡Œç¨‹ç¢‘

### Phase 1: ç¯å¢ƒæ­å»ºä¸åŸºç¡€æ¡†æ¶ï¼ˆç¬¬1-2å‘¨ï¼‰

#### ç›®æ ‡
- æ­å»ºå‰åç«¯å¼€å‘ç¯å¢ƒ
- å®ç°åŸºç¡€çš„æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
- éªŒè¯æŠ€æœ¯æ ˆå¯è¡Œæ€§

#### åç«¯ä»»åŠ¡
- [ ] åˆ›å»ºé¡¹ç›®ç›®å½•ç»“æ„
- [ ] é…ç½®Pythonè™šæ‹Ÿç¯å¢ƒ
- [ ] å®‰è£…ä¾èµ–ï¼ˆrequirements.txtï¼‰
- [ ] åˆ›å»ºFastAPIåº”ç”¨å…¥å£ï¼ˆmain.pyï¼‰
- [ ] å®ç°é…ç½®ç®¡ç†ï¼ˆconfig.pyï¼‰
- [ ] å®ç°æ–‡ä»¶ä¸Šä¼ API
- [ ] å®ç°å¥åº·æ£€æŸ¥API
- [ ] é…ç½®CORS

#### å‰ç«¯ä»»åŠ¡
- [ ] åˆ›å»ºReacté¡¹ç›®ï¼ˆViteï¼‰
- [ ] é…ç½®TypeScript
- [ ] é…ç½®Tailwind CSS
- [ ] åˆ›å»ºåŸºç¡€å¸ƒå±€ç»„ä»¶
- [ ] å®ç°æ–‡ä»¶ä¸Šä¼ ç»„ä»¶
- [ ] é…ç½®Axios

#### éªŒæ”¶æ ‡å‡†
- âœ… å‰åç«¯å¯ä»¥æ­£å¸¸å¯åŠ¨
- âœ… å¯ä»¥é€šè¿‡å‰ç«¯ä¸Šä¼ æ–‡ä»¶åˆ°åç«¯
- âœ… åç«¯å¯ä»¥ä¿å­˜æ–‡ä»¶åˆ°æŒ‡å®šç›®å½•

---

### Phase 2: PDFå¤„ç†ä¸Markdownæ¸²æŸ“ï¼ˆç¬¬3-4å‘¨ï¼‰

#### ç›®æ ‡
- å®ç°PDFè½¬Markdownæ ¸å¿ƒåŠŸèƒ½
- æ”¯æŒå›¾åƒå’Œå…¬å¼æ¸²æŸ“

#### åç«¯ä»»åŠ¡
- [ ] å®ç°PDFProcessorç±»
- [ ] é›†æˆPix2Textè¿›è¡ŒOCR
- [ ] é›†æˆPyMuPDFæå–å›¾åƒ
- [ ] å®ç°Markdownç”Ÿæˆé€»è¾‘
- [ ] å®ç°å›¾åƒAPIç«¯ç‚¹
- [ ] å®ç°æ–‡æ¡£çŠ¶æ€æŸ¥è¯¢API
- [ ] æ·»åŠ åå°å¼‚æ­¥ä»»åŠ¡

#### å‰ç«¯ä»»åŠ¡
- [ ] å®ç°Markdownæ¸²æŸ“ç»„ä»¶
- [ ] é›†æˆKaTeXæ¸²æŸ“å…¬å¼
- [ ] å®ç°å›¾åƒæ‡’åŠ è½½
- [ ] å®ç°æ–‡æ¡£æŸ¥çœ‹é¡µé¢
- [ ] æ·»åŠ æ–‡æ¡£åˆ—è¡¨é¡µé¢
- [ ] å®ç°çŠ¶æ€è½®è¯¢

#### éªŒæ”¶æ ‡å‡†
- âœ… PDFå¯ä»¥æ­£ç¡®è½¬æ¢ä¸ºMarkdown
- âœ… æ•°å­¦å…¬å¼æ­£ç¡®æ˜¾ç¤ºï¼ˆLaTeXæ ¼å¼ï¼‰
- âœ… å›¾åƒæ­£ç¡®æå–å’Œæ˜¾ç¤º
- âœ… æ–‡æ¡£å¯ä»¥æ­£å¸¸æµè§ˆ

---

### Phase 3: AIé—®ç­”åŠŸèƒ½ï¼ˆç¬¬5-6å‘¨ï¼‰

#### ç›®æ ‡
- å®ç°åŸºäºä¸Šä¸‹æ–‡çš„AIé—®ç­”
- æ”¯æŒæµå¼å“åº”

#### åç«¯ä»»åŠ¡
- [ ] å®ç°ContextBuilderç±»
- [ ] é›†æˆtiktokenè¿›è¡ŒTokenè®¡æ•°
- [ ] å®ç°æ™ºèƒ½æˆªæ–­é€»è¾‘
- [ ] å®ç°LLMServiceç±»
- [ ] é›†æˆQwen API
- [ ] å®ç°æµå¼å“åº”
- [ ] å®ç°èŠå¤©APIç«¯ç‚¹

#### å‰ç«¯ä»»åŠ¡
- [ ] å®ç°èŠå¤©ç•Œé¢ç»„ä»¶
- [ ] å®ç°æ¶ˆæ¯åˆ—è¡¨ç»„ä»¶
- [ ] å®ç°æ¶ˆæ¯è¾“å…¥ç»„ä»¶
- [ ] å®ç°SSEæµå¼æ¥æ”¶
- [ ] å®ç°æ‰“å­—æœºæ•ˆæœ
- [ ] å®ç°å¯¹è¯å†å²ç®¡ç†

#### éªŒæ”¶æ ‡å‡†
- âœ… å¯ä»¥åŸºäºæ–‡æ¡£å†…å®¹è¿›è¡Œé—®ç­”
- âœ… æµå¼å“åº”ä½“éªŒæµç•…
- âœ… å¯¹è¯å†å²æ­£ç¡®ç®¡ç†
- âœ… é”™è¯¯å¤„ç†å®Œå–„

---

### Phase 4: ä¼˜åŒ–ä¸å®Œå–„ï¼ˆç¬¬7-8å‘¨ï¼‰

#### ç›®æ ‡
- æ€§èƒ½ä¼˜åŒ–
- ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- æ”¯æŒDOCXæ ¼å¼

#### åç«¯ä»»åŠ¡
- [ ] å®ç°DOCXProcessorç±»
- [ ] ä¼˜åŒ–å¤§æ–‡ä»¶å¤„ç†
- [ ] æ·»åŠ é”™è¯¯æ—¥å¿—
- [ ] å®ç°æ–‡æ¡£åˆ é™¤åŠŸèƒ½
- [ ] æ·»åŠ ç¼“å­˜æœºåˆ¶
- [ ] æ€§èƒ½æµ‹è¯•

#### å‰ç«¯ä»»åŠ¡
- [ ] ä¼˜åŒ–å¤§æ–‡æ¡£æ¸²æŸ“æ€§èƒ½
- [ ] æ·»åŠ åŠ è½½åŠ¨ç”»
- [ ] ä¼˜åŒ–ç§»åŠ¨ç«¯é€‚é…
- [ ] æ·»åŠ å¿«æ·é”®æ”¯æŒ
- [ ] å®Œå–„é”™è¯¯æç¤º
- [ ] UI/UXä¼˜åŒ–

#### éªŒæ”¶æ ‡å‡†
- âœ… æ”¯æŒPDFå’ŒDOCXä¸¤ç§æ ¼å¼
- âœ… å¤§æ–‡æ¡£å¤„ç†æµç•…
- âœ… ç”¨æˆ·ä½“éªŒè‰¯å¥½
- âœ… é”™è¯¯æç¤ºæ¸…æ™°

---

## ğŸ” å…³é”®æŠ€æœ¯éªŒè¯

### 1. Pix2TextæŠ€æœ¯éªŒè¯

**éªŒè¯ç›®æ ‡**ï¼šç¡®è®¤Pix2Textèƒ½å¤Ÿæ»¡è¶³PDFå¤„ç†éœ€æ±‚

**éªŒè¯æ–¹æ³•**ï¼š
```python
# test_pix2text.py
from pix2text import Pix2Text

# åˆå§‹åŒ–
p2t = Pix2Text.from_config()

# æµ‹è¯•PDFå¤„ç†
result = p2t.recognize_pdf(
    'test.pdf',
    return_text=True,
    rec_config={'formula_ocr': True}
)

print(result['text'])
```

**éªŒè¯æ ‡å‡†**ï¼š
- âœ… èƒ½å¤Ÿè¯†åˆ«ä¸­è‹±æ–‡æ··æ’æ–‡æœ¬
- âœ… èƒ½å¤Ÿè¯†åˆ«æ•°å­¦å…¬å¼å¹¶è½¬ä¸ºLaTeX
- âœ… å¤„ç†é€Ÿåº¦å¯æ¥å—ï¼ˆ<5ç§’/é¡µï¼‰

---

### 2. Qwen APIéªŒè¯

**éªŒè¯ç›®æ ‡**ï¼šç¡®è®¤Qwen APIè°ƒç”¨æ­£å¸¸

**éªŒè¯æ–¹æ³•**ï¼š
```python
# test_qwen.py
import os
from dashscope import Generation
import dashscope

# è®¾ç½®APIå¯†é’¥
dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# æµ‹è¯•æµå¼è°ƒç”¨
responses = Generation.call(
    model="qwen-plus",
    prompt="ä»‹ç»ä¸€ä¸‹æœºå™¨å­¦ä¹ ",
    stream=True,
    incremental_output=True
)

for response in responses:
    if response.status_code == 200:
        print(response.output.choices[0].message.content, end='')
```

**éªŒè¯æ ‡å‡†**ï¼š
- âœ… APIå¯†é’¥æœ‰æ•ˆ
- âœ… æµå¼å“åº”æ­£å¸¸
- âœ… æ”¯æŒé•¿ä¸Šä¸‹æ–‡ï¼ˆ128k tokensï¼‰

---

### 3. ä¸Šä¸‹æ–‡é•¿åº¦æµ‹è¯•

**éªŒè¯ç›®æ ‡**ï¼šç¡®è®¤é•¿æ–‡æ¡£çš„Tokenç®¡ç†ç­–ç•¥

**éªŒè¯æ–¹æ³•**ï¼š
```python
# test_context.py
import tiktoken
from pathlib import Path

encoder = tiktoken.get_encoding("cl100k_base")

# è¯»å–æµ‹è¯•PDFè½¬æ¢çš„Markdown
md_path = Path("test_output.md")
with open(md_path, "r", encoding="utf-8") as f:
    content = f.read()

tokens = len(encoder.encode(content))
print(f"Total tokens: {tokens}")

# æµ‹è¯•æˆªæ–­
max_tokens = 120000
if tokens > max_tokens:
    # å®ç°æˆªæ–­é€»è¾‘
    pass
```

**éªŒæ”¶æ ‡å‡†**ï¼š
- âœ… Tokenè®¡æ•°å‡†ç¡®
- âœ… æˆªæ–­é€»è¾‘åˆç†
- âœ… ä¸ç ´åæ–‡æ¡£ç»“æ„

---

## âš™ï¸ ç¯å¢ƒé…ç½®

### ç³»ç»Ÿç¯å¢ƒå˜é‡

å·²ç¡®è®¤çš„ç¯å¢ƒå˜é‡ï¼š
```
DASHSCOPE_API_KEY=sk-20b503d6974144118b5f420de1c46bdc
QWEN_API_BASE=https://dashscope.aliyuncs.com/compatible-mode/v1
```

### backend/.env

```env
# APIé…ç½®
API_HOST=127.0.0.1
API_PORT=8000
API_PREFIX=/api/v1

# Qwené…ç½®ï¼ˆä»ç³»ç»Ÿç¯å¢ƒå˜é‡è¯»å–ï¼‰
# DASHSCOPE_API_KEY å·²åœ¨ç³»ç»Ÿç¯å¢ƒå˜é‡ä¸­é…ç½®

# å­˜å‚¨é…ç½®
UPLOAD_DIR=./data/uploads
PROCESSED_DIR=./data/processed

# PDFå¤„ç†é€‰é¡¹
USE_MARKER=false

# CORSé…ç½®
CORS_ORIGINS=["http://localhost:5173"]

# æ—¥å¿—é…ç½®
LOG_LEVEL=INFO
```

---

## ğŸ¨ è®¾è®¡åŸåˆ™ä¸æœ€ä½³å®è·µ

### SOLIDåŸåˆ™åº”ç”¨

1. **å•ä¸€èŒè´£åŸåˆ™ï¼ˆSRPï¼‰**
   - PDFProcessoråªè´Ÿè´£PDFå¤„ç†
   - ContextBuilderåªè´Ÿè´£ä¸Šä¸‹æ–‡ç®¡ç†
   - LLMServiceåªè´Ÿè´£LLMè°ƒç”¨

2. **å¼€é—­åŸåˆ™ï¼ˆOCPï¼‰**
   - é€šè¿‡é…ç½®åˆ‡æ¢Pix2Text/marker-pdf
   - é€šè¿‡æŠ½è±¡æ¥å£æ”¯æŒå¤šç§æ–‡æ¡£ç±»å‹

3. **é‡Œæ°æ›¿æ¢åŸåˆ™ï¼ˆLSPï¼‰**
   - PDFProcessorå’ŒDOCXProcessorå®ç°ç›¸åŒæ¥å£
   - å¯ä»¥äº’æ¢ä½¿ç”¨

4. **æ¥å£éš”ç¦»åŸåˆ™ï¼ˆISPï¼‰**
   - APIç«¯ç‚¹èŒè´£æ˜ç¡®
   - æ¯ä¸ªæ¨¡å—æš´éœ²æœ€å°æ¥å£

5. **ä¾èµ–å€’ç½®åŸåˆ™ï¼ˆDIPï¼‰**
   - ä¸šåŠ¡é€»è¾‘ä¾èµ–æŠ½è±¡
   - é€šè¿‡ä¾èµ–æ³¨å…¥ç®¡ç†æœåŠ¡

### ä»£ç è§„èŒƒ

- ä½¿ç”¨ç±»å‹æç¤ºï¼ˆType Hintsï¼‰
- ä½¿ç”¨Pydanticè¿›è¡Œæ•°æ®éªŒè¯
- ä½¿ç”¨async/awaitå¤„ç†å¼‚æ­¥æ“ä½œ
- å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- å•å…ƒæµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½

---

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

```python
# tests/test_pdf_processor.py
import pytest
from app.core.pdf_processor import PDFProcessor

def test_pdf_to_markdown():
    processor = PDFProcessor()
    markdown, images = processor.process(
        "test_data/sample.pdf",
        "test_doc_id",
        "test_output"
    )

    assert markdown is not None
    assert len(markdown) > 0
    assert isinstance(images, list)

# tests/test_llm_service.py
import pytest
from app.core.llm_service import LLMService

@pytest.mark.asyncio
async def test_stream_chat():
    service = LLMService()
    prompt = "ä»‹ç»ä¸€ä¸‹æœºå™¨å­¦ä¹ "

    chunks = []
    async for chunk in service.stream_chat(prompt):
        chunks.append(chunk)

    assert len(chunks) > 0
    assert all(isinstance(c, str) for c in chunks)
```

### é›†æˆæµ‹è¯•

```python
# tests/test_api.py
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_upload_document():
    with open("test_data/sample.pdf", "rb") as f:
        response = client.post(
            "/api/v1/documents/upload",
            files={"file": ("sample.pdf", f, "application/pdf")}
        )

    assert response.status_code == 200
    assert "doc_id" in response.json()

def test_chat():
    response = client.post(
        "/api/v1/chat/message",
        json={
            "doc_id": "test_doc_id",
            "question": "è¿™ç¯‡è®ºæ–‡çš„ä¸»è¦å†…å®¹æ˜¯ä»€ä¹ˆï¼Ÿ",
            "history": []
        }
    )

    assert response.status_code == 200
```

---

## ğŸ“Š æ€§èƒ½ç›®æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ | è¯´æ˜ |
|------|--------|------|
| PDFè½¬æ¢é€Ÿåº¦ | <5ç§’/é¡µ | ä½¿ç”¨Pix2Text |
| æ–‡æ¡£ä¸Šä¼  | <10MBæ”¯æŒ | å¤§éƒ¨åˆ†è®ºæ–‡åœ¨æ­¤èŒƒå›´ |
| AIå“åº”å»¶è¿Ÿ | <2ç§’é¦–token | æµå¼å“åº” |
| å‰ç«¯åŠ è½½æ—¶é—´ | <3ç§’ | é¦–å±æ¸²æŸ“ |
| å¹¶å‘æ”¯æŒ | 10ä¸ªç”¨æˆ· | æœ¬åœ°éƒ¨ç½²è¶³å¤Ÿ |

---

## âš ï¸ é£é™©ä¸ç¼“è§£æªæ–½

| é£é™© | å½±å“ | æ¦‚ç‡ | ç¼“è§£æªæ–½ |
|------|------|------|---------|
| Pix2Textè¯†åˆ«å‡†ç¡®ç‡ä½ | ä¸­ | ä¸­ | æä¾›marker-pdfå‡çº§é€‰é¡¹ |
| æ–‡æ¡£è¶…å‡ºä¸Šä¸‹æ–‡é™åˆ¶ | ä¸­ | ä½ | æ™ºèƒ½æˆªæ–­ç­–ç•¥ |
| Qwen APIä¸ç¨³å®š | é«˜ | ä½ | é”™è¯¯é‡è¯•æœºåˆ¶ |
| ä¾èµ–å®‰è£…å›°éš¾ | ä½ | ä¸­ | æä¾›Dockeræ–¹æ¡ˆ |
| Windowså…¼å®¹æ€§é—®é¢˜ | ä¸­ | ä½ | æµ‹è¯•æ‰€æœ‰ä¾èµ– |

---

## ğŸ“š å‚è€ƒèµ„æº

### å®˜æ–¹æ–‡æ¡£
- [FastAPIæ–‡æ¡£](https://fastapi.tiangolo.com/)
- [Pix2Textæ–‡æ¡£](https://github.com/breezedeus/Pix2Text)
- [PyMuPDFæ–‡æ¡£](https://pymupdf.readthedocs.io/)
- [Qwen APIæ–‡æ¡£](https://help.aliyun.com/zh/dashscope/)
- [Reactæ–‡æ¡£](https://react.dev/)
- [KaTeXæ–‡æ¡£](https://katex.org/)

### æŠ€æœ¯åšå®¢
- [Pix2Textå®æˆ˜ç»éªŒ](https://mp.weixin.qq.com/s/...)
- [FastAPIå¼‚æ­¥æœ€ä½³å®è·µ](https://realpython.com/async-io-python/)
- [Reactæµå¼UIæ›´æ–°](https://dev.to/...)

---

## âœ… æ€»ç»“

### æ¶æ„ä¼˜åŠ¿

1. **ç®€æ´é«˜æ•ˆ**
   - ç§»é™¤å‘é‡æ•°æ®åº“ï¼Œé™ä½å¤æ‚åº¦
   - ä½¿ç”¨Pix2Textï¼Œå¤„ç†é€Ÿåº¦å¿«
   - åŸºäºä¸Šä¸‹æ–‡é—®ç­”ï¼Œå®ç°ç®€å•

2. **æˆæœ¬å¯æ§**
   - ä½¿ç”¨Qwenï¼Œæ€§ä»·æ¯”é«˜
   - æœ¬åœ°éƒ¨ç½²ï¼Œæ— é¢å¤–æœåŠ¡å™¨æˆæœ¬
   - æ•°æ®éšç§å®‰å…¨

3. **æ˜“äºå‡çº§**
   - ä¿ç•™marker-pdfå‡çº§è·¯å¾„
   - å¯é…ç½®åˆ‡æ¢LLM
   - æ¨¡å—åŒ–è®¾è®¡ï¼Œä¾¿äºæ‰©å±•

### é¢„æœŸæ•ˆæœ

- âœ… 2å‘¨å†…å®ŒæˆMVP
- âœ… æ”¯æŒPDF/DOCXæ ¼å¼
- âœ… å‡†ç¡®æå–å›¾åƒå’Œå…¬å¼
- âœ… æµç•…çš„AIé—®ç­”ä½“éªŒ
- âœ… å‹å¥½çš„ç”¨æˆ·ç•Œé¢

### åç»­è¿­ä»£æ–¹å‘

1. **åŠŸèƒ½å¢å¼º**
   - æ”¯æŒæ›´å¤šæ–‡æ¡£æ ¼å¼ï¼ˆEPUBç­‰ï¼‰
   - æ·»åŠ æ–‡æ¡£æ‰¹æ³¨åŠŸèƒ½
   - æ”¯æŒæ–‡çŒ®å¼•ç”¨ç®¡ç†

2. **æ€§èƒ½ä¼˜åŒ–**
   - å‡çº§åˆ°marker-pdfæå‡è´¨é‡
   - å¼•å…¥å‘é‡æ•°æ®åº“æ”¯æŒé•¿æ–‡æ¡£
   - æ·»åŠ ç¼“å­˜æœºåˆ¶

3. **ç”¨æˆ·ä½“éªŒ**
   - ç§»åŠ¨ç«¯é€‚é…
   - å¤šä¸»é¢˜æ”¯æŒ
   - å¿«æ·é”®æ”¯æŒ

---

**å¼€å‘è®¡åˆ’ç‰ˆæœ¬**ï¼šv1.0
**åˆ›å»ºæ—¶é—´**ï¼š2026-01-12
**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š2026-03-12ï¼ˆ8å‘¨ï¼‰
**è´Ÿè´£äºº**ï¼šå¼€å‘å›¢é˜Ÿ
